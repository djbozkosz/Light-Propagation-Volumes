Todo:

ok kuličky lpv
ok zrušení fixed planes
ok cascaded SM
ok point SM
ok cascaded LPV
ok inject GV

tilované kaskády s instancingem:
  vypočítat a uložit si frusta pro kaskády
  při renderu meshe projet aabb přes všechny frusta - pozpátku
  a najít úrovně kdy je ještě vidět a kdy ne
  vykreslit počet instancí, kolik jich je ještě vidět
  do vs hodit uniform na počet dělení tilů
  dle čísla instance pak zvolit ořezání

lpv vstup:
  g-buffer: (amb, pos, normal) 2d tex array - x * y * 6*sun/sky dirs		3 textury

výstup - out vstup:
  stíny: 2d tex array: x * y * z						1 textura
  lpv: 3d tex: 3(rgb) * x*6 * y * z						3 textury

gl3:
  dva swap fbo - 3d tex: 4(rgbg) * x*6 * y * z					2 fbo + 8 textur
  injekce:
    +blend
    -depth mask
    bind fbo 0
    vs: draw points fbo w * h
    gs: by vertex_id select gl_layer - send point into layer
    fs: store point in lpv: r, g, b, gv layers
  propagace:
    for(p : proc_cnt)
      bind fbo 1/0
      vs: draw points * lpv depth
      gs: expand to fs quad, select layer by vertex_id
      fs: compute lpv by gathering from lpv 0/1, out into r,g,b lpv 1/0
      swap fbo 1/0

gl4:
  dva swap image - r32i: 3d tex: 3(rgb) * x*4*6 * y * z   +   3d gv		7 textur
  image load store: itof: float(a) * 0.000001, ftoi int(a * 1000000.0)
  injekce:
    atomicAdd 4x pro 4 sh koef * 3 barvy + gv
    do lpv0
  prop:
    for(p : proc_cnt)
      distribute lpv from lpv0/1 into lpv1/0, atomicAdd
      barrier
      swwap 1/0
    merge r32i channels into r, g, b tex3ds

both gl3 / gl4:
  render:
    for drawing bind lpv tex 0/1

kaskády 32^3: velikost - dosah
  0.1m - 1.6m
  0.3m - 4.8m
  0.8m - 12.8m
  2m - 32m
  6m - 96m
  20m - 320m
  100m - 1600m

ukládání matic:
  geometry:
    u modelu: cyklus co getne z enginu viewProj matice geometry kaskád,
    vynásobí je s modelWorld a všechny uloží do techniky
  stíny:
    úplně stejně pro stíny akorát výsledek ještě vynásobí s bias maticí a uloží taky
